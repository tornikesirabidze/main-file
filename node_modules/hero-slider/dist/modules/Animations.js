'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var HeroSlider_module = require('../HeroSlider.module.css.js');
var Accessibility = require('./Accessibility.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

var SlidingAnimation;
(function (SlidingAnimation) {
    SlidingAnimation["TOP_TO_BOTTOM"] = "top_to_bottom";
    SlidingAnimation["BOTTOM_TO_TOP"] = "bottom_to_top";
    SlidingAnimation["LEFT_TO_RIGHT"] = "left_to_right";
    SlidingAnimation["RIGHT_TO_LEFT"] = "right_to_left";
    SlidingAnimation["FADE"] = "fade";
})(SlidingAnimation || (SlidingAnimation = {}));
const SlidingAnimationCssClassMap = {
    [SlidingAnimation.FADE]: HeroSlider_module["default"].Sliding_Fade_In,
    [SlidingAnimation.TOP_TO_BOTTOM]: HeroSlider_module["default"].Sliding_Top_To_Bottom,
    [SlidingAnimation.BOTTOM_TO_TOP]: HeroSlider_module["default"].Sliding_Bottom_To_Top,
    [SlidingAnimation.LEFT_TO_RIGHT]: HeroSlider_module["default"].Sliding_Left_To_Right,
    [SlidingAnimation.RIGHT_TO_LEFT]: HeroSlider_module["default"].Sliding_Right_To_Left
};
const defaultProps = {
    slidingAnimation: 'wipe',
    sliderFadeInDuration: 100,
    navbarFadeInDuration: 1000,
    navbarFadeInDelay: 500,
    shouldManageAnimationSequence: true
};
const AnimationsStateContext = React__default["default"].createContext(undefined);
function AnimationsProvider({ children, animations }) {
    var _a, _b, _c, _d;
    const { orientation } = Accessibility.useAccessibility();
    const params = {
        slidingAnimation: (animations === null || animations === void 0 ? void 0 : animations.slidingAnimation) || defaultProps.slidingAnimation,
        sliderFadeInDuration: (_a = animations === null || animations === void 0 ? void 0 : animations.sliderFadeInDuration) !== null && _a !== void 0 ? _a : defaultProps.sliderFadeInDuration,
        navbarFadeInDuration: (_b = animations === null || animations === void 0 ? void 0 : animations.navbarFadeInDuration) !== null && _b !== void 0 ? _b : defaultProps.navbarFadeInDuration,
        navbarFadeInDelay: (_c = animations === null || animations === void 0 ? void 0 : animations.navbarFadeInDelay) !== null && _c !== void 0 ? _c : defaultProps.navbarFadeInDelay,
        shouldManageAnimationSequence: (_d = animations === null || animations === void 0 ? void 0 : animations.shouldManageAnimationSequence) !== null && _d !== void 0 ? _d : defaultProps.shouldManageAnimationSequence
    };
    const getSlidingAnimationCssClass = (activeSlide, prevActiveSlide, slidingDirection) => {
        const getSlidingAnimation = () => {
            switch (params.slidingAnimation) {
                case 'fade':
                    return SlidingAnimation.FADE;
                case 'wipe': {
                    let direction;
                    if (slidingDirection)
                        direction = slidingDirection;
                    else {
                        const isSlidingForward = activeSlide > prevActiveSlide;
                        direction = isSlidingForward ? 'forward' : 'backward';
                    }
                    if (direction === 'forward')
                        return orientation === Accessibility.AccessibilityOrientation.HORIZONTAL
                            ? SlidingAnimation.RIGHT_TO_LEFT
                            : SlidingAnimation.BOTTOM_TO_TOP;
                    else
                        return orientation === Accessibility.AccessibilityOrientation.HORIZONTAL
                            ? SlidingAnimation.LEFT_TO_RIGHT
                            : SlidingAnimation.TOP_TO_BOTTOM;
                }
                default: {
                    throw new Error(`Unhandled sliding animation: [${params.slidingAnimation}]`);
                }
            }
        };
        return SlidingAnimationCssClassMap[getSlidingAnimation()];
    };
    // NOTE: you *might* need to memoize this value
    // Learn more in http://kcd.im/optimize-context
    const value = {
        sliderFadeInDuration: params.sliderFadeInDuration,
        navbarFadeInDuration: params.sliderFadeInDuration,
        navbarFadeInDelay: params.sliderFadeInDuration,
        getSlidingAnimationCssClass
    };
    return (jsxRuntime.jsx(AnimationsStateContext.Provider, Object.assign({ value: value }, { children: children })));
}
function useAnimations() {
    const context = React__default["default"].useContext(AnimationsStateContext);
    if (context === undefined) {
        throw new Error('useAnimations must be used within a AnimationsProvider');
    }
    return context;
}

exports.AnimationsProvider = AnimationsProvider;
exports.useAnimations = useAnimations;
//# sourceMappingURL=Animations.js.map
