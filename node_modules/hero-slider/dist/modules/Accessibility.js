'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var Controller = require('./Controller.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

/**
 * `AccessibilityOrientation` definition used for the `SliderProps.orientation` prop.
 * Used to define which swipes (depending on directions) will change the slides,
 * and where and how will the buttons render, if set to render.
 */
exports.AccessibilityOrientation = void 0;
(function (AccessibilityOrientation) {
    AccessibilityOrientation["VERTICAL"] = "vertical";
    AccessibilityOrientation["HORIZONTAL"] = "horizontal";
})(exports.AccessibilityOrientation || (exports.AccessibilityOrientation = {}));
const defaultProps = {
    shouldDisplayButtons: true,
    shouldSlideOnArrowKeypress: true,
    orientation: exports.AccessibilityOrientation.HORIZONTAL,
    thresholdToSlide: 50
};
const AccessibilityStateContext = React__default["default"].createContext(undefined);
function accessibilityReducer(state, action) {
    switch (action.type) {
        case 'start-motion': {
            return {
                initialX: action.payload.x,
                initialY: action.payload.y,
                currentX: undefined,
                currentY: undefined
            };
        }
        case 'update-motion': {
            return {
                initialX: state.initialX,
                initialY: state.initialY,
                currentX: action.payload.x,
                currentY: action.payload.y
            };
        }
        case 'end-motion': {
            return {
                initialX: undefined,
                initialY: undefined,
                currentX: undefined,
                currentY: undefined
            };
        }
        default: {
            throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
        }
    }
}
function AccessibilityProvider({ children, accessibility }) {
    var _a, _b, _c;
    const params = {
        shouldDisplayButtons: (_a = accessibility === null || accessibility === void 0 ? void 0 : accessibility.shouldDisplayButtons) !== null && _a !== void 0 ? _a : defaultProps.shouldDisplayButtons,
        shouldSlideOnArrowKeypress: (_b = accessibility === null || accessibility === void 0 ? void 0 : accessibility.shouldSlideOnArrowKeypress) !== null && _b !== void 0 ? _b : defaultProps.shouldSlideOnArrowKeypress,
        orientation: (accessibility === null || accessibility === void 0 ? void 0 : accessibility.orientation) || defaultProps.orientation,
        thresholdToSlide: (_c = accessibility === null || accessibility === void 0 ? void 0 : accessibility.thresholdToSlide) !== null && _c !== void 0 ? _c : defaultProps.thresholdToSlide
    };
    const [state, dispatch] = React__default["default"].useReducer(accessibilityReducer, {
        initialX: undefined,
        initialY: undefined,
        currentX: undefined,
        currentY: undefined
    });
    const { goToNextSlide, goToPreviousSlide } = Controller.useController();
    /**
     * Sets the initial coordinates of the touch event.
     */
    const onTouchStartHandler = (event) => {
        dispatch({
            type: 'start-motion',
            payload: {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            }
        });
    };
    /**
     * Sets the current coordinates of the touch event to the state.
     */
    const onTouchMoveHandler = (event) => {
        dispatch({
            type: 'update-motion',
            payload: {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            }
        });
    };
    /**
     * Determines in which direction **and** sense (vector) the user is swiping.
     * Animations are then set accordingly depending on which direction the user is dragging and the slide is changed.
     * Finally the touch state is set back to the initial state, where everything is undefined.
     */
    const onTouchEndHandler = () => {
        const diffX = Number(state.initialX) - Number(state.currentX);
        const diffY = Number(state.initialY) - Number(state.currentY);
        const isSlidingHorizontally = Math.abs(diffX) > Math.abs(diffY);
        const isSliderSetHorizontally = params.orientation === exports.AccessibilityOrientation.HORIZONTAL;
        const isSliderSetVertically = params.orientation === exports.AccessibilityOrientation.VERTICAL;
        if (isSlidingHorizontally &&
            isSliderSetHorizontally &&
            Math.abs(diffX) >= params.thresholdToSlide) {
            const isSwipingRight = diffX > 0;
            if (isSwipingRight)
                goToNextSlide();
            else
                goToPreviousSlide();
        }
        else if (!isSlidingHorizontally &&
            isSliderSetVertically &&
            Math.abs(diffY) >= params.thresholdToSlide) {
            const isSwipingUp = diffY > 0;
            if (isSwipingUp)
                goToNextSlide();
            else
                goToPreviousSlide();
        }
        dispatch({ type: 'end-motion' });
    };
    const onArrowKeypressHandler = (e) => {
        if (!params.shouldSlideOnArrowKeypress)
            return;
        const code = e.key || e.code || e.keyCode;
        const isHorizontal = params.orientation === exports.AccessibilityOrientation.HORIZONTAL;
        switch (true) {
            // Left keypress.
            case isHorizontal && (code === 'ArrowLeft' || code === 37):
                goToPreviousSlide();
                break;
            // Right keypress.
            case isHorizontal && (code === 'ArrowRight' || code === 39):
                goToNextSlide();
                break;
            // Up keypress.
            case !isHorizontal && (code === 'ArrowUp' || code === 38):
                goToPreviousSlide();
                break;
            // Down keypress.
            case !isHorizontal && (code === 'ArrowDown' || code === 40):
                goToNextSlide();
                break;
        }
    };
    /**
     * After mounting, similar to `componentDidMount`, setup the window event listeners for keydowns. The event handlers will be changing the slides if enabled to do so.
     */
    React__default["default"].useEffect(() => {
        window.addEventListener('keydown', onArrowKeypressHandler);
        /**
         * Clearing any existing timeouts to avoid memory leaks, and clear event listener.
         */
        return () => {
            window.removeEventListener('keydown', onArrowKeypressHandler);
        };
    }, [onArrowKeypressHandler]);
    // NOTE: you *might* need to memoize this value
    // Learn more in http://kcd.im/optimize-context
    const value = {
        state,
        shouldDisplayButtons: params.shouldDisplayButtons,
        orientation: params.orientation,
        onTouchStartHandler,
        onTouchMoveHandler,
        onTouchEndHandler
    };
    return (jsxRuntime.jsx(AccessibilityStateContext.Provider, Object.assign({ value: value }, { children: children })));
}
function useAccessibility() {
    const context = React__default["default"].useContext(AccessibilityStateContext);
    if (context === undefined) {
        throw new Error('useAccessibility must be used within a AccessibilityProvider');
    }
    return context;
}

exports.AccessibilityProvider = AccessibilityProvider;
exports.useAccessibility = useAccessibility;
//# sourceMappingURL=Accessibility.js.map
